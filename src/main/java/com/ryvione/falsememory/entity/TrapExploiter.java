package com.ryvione.falsememory.entity;

import com.ryvione.falsememory.memory.PlayerMemory;
import com.ryvione.falsememory.tracking.TrapAnalyzer;
import net.minecraft.core.BlockPos;
import net.minecraft.server.level.ServerLevel;
import net.minecraft.server.level.ServerPlayer;
import net.minecraft.world.entity.PathfinderMob;
import net.minecraft.world.phys.Vec3;

import java.util.List;

public class TrapExploiter {

    private PathfinderMob entity;
    private ServerPlayer target;
    private PlayerMemory memory;
    private ServerLevel level;

    public TrapExploiter(PathfinderMob entity, ServerPlayer target, PlayerMemory memory, ServerLevel level) {
        this.entity = entity;
        this.target = target;
        this.memory = memory;
        this.level = level;
    }

    public boolean shouldLureIntoTrap(double distanceToTarget) {
        if (memory.detectedTraps.isEmpty()) return false;
        
        for (TrapAnalyzer.TrapMechanism trap : memory.detectedTraps) {
            if (entity.distanceToSqr(trap.triggerPos.getX(), trap.triggerPos.getY(), trap.triggerPos.getZ()) < 100) {
                return true;
            }
        }
        return false;
    }

    public BlockPos findOptimalTrapLure() {
        if (memory.detectedTraps.isEmpty()) return null;

        TrapAnalyzer.TrapMechanism bestTrap = null;
        double closestDistance = Double.MAX_VALUE;

        for (TrapAnalyzer.TrapMechanism trap : memory.detectedTraps) {
            if (trap.complexity >= 2) {
                double distToTarget = target.distanceToSqr(trap.triggerPos.getX(), trap.triggerPos.getY(), trap.triggerPos.getZ());
                if (distToTarget < closestDistance) {
                    closestDistance = distToTarget;
                    bestTrap = trap;
                }
            }
        }

        return bestTrap != null ? bestTrap.triggerPos : null;
    }

    public void lureTowardsTrap(BlockPos trapPos) {
        if (trapPos == null) return;

        Vec3 trapVec = Vec3.atCenterOf(trapPos);
        Vec3 playerPos = target.position();
        Vec3 directionFromTrap = playerPos.subtract(trapVec).normalize();

        Vec3 lurePoint = trapVec.add(directionFromTrap.scale(3));
        entity.getNavigation().moveTo(lurePoint.x, lurePoint.y, lurePoint.z, 1.0);
    }

    public boolean canAvoidTrap(BlockPos checkPos) {
        TrapAnalyzer.TrapMechanism trapAtPos = TrapAnalyzer.findTrapAt(memory, checkPos, 2);
        return trapAtPos == null;
    }

    public void disableTrapBlocks(BlockPos centerPos) {
        for (TrapAnalyzer.TrapMechanism trap : memory.detectedTraps) {
            if (trap.triggerPos.closerThan(centerPos, 16)) {
                for (BlockPos affected : trap.affectedBlocks) {
                    if (level.getBlockState(affected).blocksMotion()) {
                        level.destroyBlock(affected, false);
                    }
                }
            }
        }
    }

    public Vec3 predictPlayerTrapCollision() {
        if (memory.detectedTraps.isEmpty()) return null;

        List<TrapAnalyzer.TrapMechanism> nearbyTraps = memory.detectedTraps.stream()
            .filter(t -> target.distanceToSqr(t.triggerPos.getX(), t.triggerPos.getY(), t.triggerPos.getZ()) < 400)
            .toList();

        if (nearbyTraps.isEmpty()) return null;

        TrapAnalyzer.TrapMechanism closestTrap = nearbyTraps.get(0);
        Vec3 playerVelocity = target.getDeltaMovement();
        Vec3 predictedPos = target.position().add(playerVelocity.scale(10));

        if (predictedPos.closerThan(Vec3.atCenterOf(closestTrap.triggerPos), 5)) {
            return closestTrap.triggerPos.getCenter();
        }

        return null;
    }

    public int getTrapAvoidanceScore(BlockPos pos) {
        int score = 0;
        for (TrapAnalyzer.TrapMechanism trap : memory.detectedTraps) {
            if (pos.closerThan(trap.triggerPos, 3)) {
                score += trap.complexity;
            }
        }
        return score;
    }

    public boolean shouldFakeFlee(BlockPos currentPos) {
        int trapScore = getTrapAvoidanceScore(currentPos);
        return trapScore > 3 && entity.getHealth() / entity.getMaxHealth() > 0.5f;
    }

    public void setTrapLearned(TrapAnalyzer.TrapMechanism trap) {
        memory.learnedTrapPatterns.add(trap.trapType);
    }

    public boolean hasLearned(String trapType) {
        return memory.learnedTrapPatterns.contains(trapType);
    }
}